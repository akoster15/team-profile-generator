"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _HTMLContentModel = _interopRequireDefault(require("./HTMLContentModel"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const phrasingCategories = ['textual', 'edits', 'anchor'];
const translatableBlockCategories = ['tabular', 'grouping', 'sectioning'];
/**
 * An object to specify custom tags.
 *
 * @typeParam T - The name of the tag to which the model will apply.
 * @typeParam M - The {@link HTMLContentModel} associated with this tag.
 */

/**
 * An object defining engine internals for tags, such as default styles
 * (UAStyles), content model (how this tag is treated during hoisting)... etc.
 *
 * @typeParam T - The name of the tag to which the model will apply.
 * @typeParam M - The {@link HTMLContentModel} associated with this tag.
 */
class HTMLElementModel {
  /**
   * The tag name associated with this model.
   */

  /**
   * The {@link HTMLContentModel} attached to this model.
   */

  /**
   * An opaque element translated {@link TNode} will have no translated {@link TNode}
   * children.
   */

  /**
   * `true` when the associated tag is a {@link https://html.spec.whatwg.org/multipage/syntax.html#void-elements | void element}.
   *
   * @remarks
   *
   * - Void elements cannot have children.
   * - TText-translated void elements will be preserved even though they don't
   *   have children.
   */

  /**
   * Equivalent of "user-agent" styles. The default styles for the element.
   *
   * @remarks These styles will be merged over by `tagsStyles`.
   */

  /**
   * A function to create conditional "user-agent" styles.
   *
   * @remarks For example, &lt;a&gt; tags will have underline decoration and be
   * colored blue only when `href` is defined.
   */

  /**
   * Derive markers for one TNode.
   */
  constructor({
    tagName,
    contentModel,
    isOpaque,
    mixedUAStyles,
    isVoid,
    getUADerivedStyleFromAttributes,
    setMarkersForTNode
  }) {
    _defineProperty(this, "tagName", void 0);

    _defineProperty(this, "contentModel", void 0);

    _defineProperty(this, "isOpaque", void 0);

    _defineProperty(this, "isVoid", void 0);

    _defineProperty(this, "mixedUAStyles", void 0);

    _defineProperty(this, "getUADerivedStyleFromAttributes", void 0);

    _defineProperty(this, "setMarkersForTNode", void 0);

    this.tagName = tagName;
    this.contentModel = contentModel;
    this.isOpaque = isOpaque || false;
    this.isVoid = isVoid;
    this.mixedUAStyles = mixedUAStyles;
    this.getUADerivedStyleFromAttributes = getUADerivedStyleFromAttributes;
    this.setMarkersForTNode = setMarkersForTNode;
  }
  /**
   * Create an {@link HTMLElementModel} from a custom description.
   *
   * @param customElementModel - The custom model declaration.
   */


  static fromCustomModel(customElementModel) {
    const {
      contentModel,
      tagName,
      isOpaque = false,
      isVoid = false,
      ...optionalFields
    } = customElementModel;
    return new HTMLElementModel({
      tagName,
      contentModel,
      isOpaque,
      isVoid,
      ...optionalFields
    });
  }
  /**
   * Create an {@link HTMLElementModel} from a native description.
   *
   * @param nativeElementModel - The native model declaration.
   */


  static fromNativeModel(nativeElementModel) {
    const {
      tagName,
      category,
      isOpaque,
      mixedUAStyles,
      isVoid = false,
      getUADerivedStyleFromAttributes,
      setMarkersForTNode: getMarkersForTNode
    } = nativeElementModel;
    const isPhrasing = phrasingCategories.indexOf(category) !== -1;
    const isTranslatable = isPhrasing || translatableBlockCategories.indexOf(category) !== -1;
    const contentModel = category === 'anchor' || category === 'edits' ? _HTMLContentModel.default.mixed : isPhrasing ? _HTMLContentModel.default.textual : isTranslatable ? _HTMLContentModel.default.block : _HTMLContentModel.default.none;
    return new HTMLElementModel({
      tagName,
      isVoid,
      contentModel: contentModel,
      mixedUAStyles,
      isOpaque: isOpaque !== null && isOpaque !== void 0 ? isOpaque : category === 'embedded',
      getUADerivedStyleFromAttributes,
      setMarkersForTNode: getMarkersForTNode
    });
  }

  isTranslatableBlock() {
    return this.contentModel === _HTMLContentModel.default.block;
  }

  isTranslatableTextual() {
    return this.contentModel === _HTMLContentModel.default.textual || this.contentModel === _HTMLContentModel.default.mixed;
  }
  /**
   * Create a new {@link HTMLElementModel} by merging properties into this model.
   *
   * @param properties - The {@link HTMLElementModelProperties} to merge into this model.
   * @typeParam CM - The {@link HTMLContentModel} attached to the new model.
   */


  extend(properties) {
    return new HTMLElementModel({ ...this,
      ...properties
    });
  }
  /**
   * A function to create conditional "user-agent" styles.
   *
   * @remarks For example, &lt;a&gt; tags will have underline decoration and be
   * colored blue only when `href` is defined.
   */


  getUADerivedCSSProcessedPropsFromAttributes(attributes, markers) {
    if (this.getUADerivedStyleFromAttributes) {
      return this.getUADerivedStyleFromAttributes(attributes, markers);
    }

    return null;
  }

}

exports.default = HTMLElementModel;
//# sourceMappingURL=HTMLElementModel.js.map